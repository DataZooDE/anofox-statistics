// NEW CODE to replace lines 438-482 in OlsArrayFinalize function:

		// Use libanostat OLSSolver (handles intercept and centering automatically)
		auto lib_result = bridge::LibanostatWrapper::FitOLS(state.y_values, state.x_matrix, state.options, true);

		// Extract results
		double intercept = lib_result.intercept;
		Eigen::VectorXd x_means = lib_result.x_train_means;
		idx_t rank = lib_result.rank; // Already includes intercept if fitted!

		// Compute predictions
		Eigen::VectorXd y_pred(n);
		for (idx_t i = 0; i < n; i++) {
			y_pred(i) = intercept;
			for (idx_t j = 0; j < p; j++) {
				if (!std::isnan(lib_result.coefficients(j))) {
					y_pred(i) += lib_result.coefficients(j) * state.x_matrix[i][j];
				}
			}
		}

		// Compute R²
		Eigen::VectorXd y_eigen(n);
		for (idx_t i = 0; i < n; i++) {
			y_eigen(i) = state.y_values[i];
		}
		Eigen::VectorXd residuals = y_eigen - y_pred;
		double ss_res = residuals.squaredNorm();

		double ss_tot;
		if (state.options.intercept) {
			double mean_y = 0.0;
			for (idx_t i = 0; i < n; i++) {
				mean_y += state.y_values[i];
			}
			mean_y /= n;
			ss_tot = 0.0;
			for (idx_t i = 0; i < n; i++) {
				double diff = state.y_values[i] - mean_y;
				ss_tot += diff * diff;
			}
		} else {
			ss_tot = 0.0;
			for (idx_t i = 0; i < n; i++) {
				ss_tot += state.y_values[i] * state.y_values[i];
			}
		}

		double r2 = (ss_tot > 1e-10) ? (1.0 - ss_res / ss_tot) : 0.0;

		// Adjusted R²: lib_result.rank already includes intercept
		idx_t df_model = rank;
		double adj_r2 = 1.0 - (1.0 - r2) * (n - 1) / (n - df_model);

		// Store coefficients in child vector (NaN for aliased -> will be NULL)
		auto coef_data = FlatVector::GetData<double>(coef_child);
		auto &coef_validity = FlatVector::Validity(coef_child);
		for (idx_t j = 0; j < p; j++) {
			if (std::isnan(lib_result.coefficients(j))) {
				// Aliased coefficient -> set as invalid (NULL)
				coef_validity.SetInvalid(list_offset + j);
				coef_data[list_offset + j] = 0.0; // Placeholder value
			} else {
				coef_data[list_offset + j] = lib_result.coefficients(j);
			}
		}

		// Set list entry for coefficients
		list_entries[result_idx] = list_entry_t {list_offset, p};

		// Compute extended metadata
		// 1. MSE
		idx_t df_residual = n - df_model;
		double mse = (df_residual > 0) ? (ss_res / df_residual) : std::numeric_limits<double>::quiet_NaN();

		// 2. Intercept standard error
		double intercept_se = std::numeric_limits<double>::quiet_NaN();
		if (state.options.intercept && lib_result.has_std_errors && df_residual > 0) {
			intercept_se = lib_result.intercept_std_error;
		}

		// 3. Store x_train_means in list (same offset as coefficients)
		auto x_means_data = FlatVector::GetData<double>(x_means_child);
		for (idx_t j = 0; j < p; j++) {
			x_means_data[list_offset + j] = x_means(j);
		}
		x_means_list_entries[result_idx] = list_entry_t {list_offset, p};

		// 4. Store coefficient_std_errors in list (same offset as coefficients)
		auto coef_se_data = FlatVector::GetData<double>(coef_se_child);
		auto &coef_se_validity = FlatVector::Validity(coef_se_child);
		for (idx_t j = 0; j < p; j++) {
			if (lib_result.has_std_errors && !std::isnan(lib_result.std_errors(j))) {
				coef_se_data[list_offset + j] = lib_result.std_errors(j);
			} else {
				coef_se_validity.SetInvalid(list_offset + j);
				coef_se_data[list_offset + j] = 0.0;
			}
		}
		coef_se_list_entries[result_idx] = list_entry_t {list_offset, p};
