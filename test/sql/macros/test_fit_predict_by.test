# name: test/sql/macros/test_fit_predict_by.test
# description: Test fit_predict_by table macros
# group: [macros]

require anofox_statistics

# =============================================================================
# SETUP: Create regression data with multiple groups
# =============================================================================

statement ok
CREATE TABLE reg_data AS
SELECT * FROM (VALUES
    ('A', 1.0, 2.0, 5.1),
    ('A', 2.0, 4.0, 10.2),
    ('A', 3.0, 6.0, 15.0),
    ('A', 4.0, 8.0, 20.1),
    ('A', 5.0, 10.0, 25.0),
    ('A', NULL, 12.0, NULL),
    ('B', 1.0, 3.0, 8.0),
    ('B', 2.0, 6.0, 16.1),
    ('B', 3.0, 9.0, 24.0),
    ('B', 4.0, 12.0, 32.2),
    ('B', 5.0, 15.0, 40.0),
    ('B', NULL, 18.0, NULL)
) AS t(group_id, x1, x2, y);

# =============================================================================
# OLS_FIT_PREDICT_BY TESTS
# =============================================================================

# TEST 1: Basic functionality - returns results
query I
SELECT COUNT(*) > 0 FROM ols_fit_predict_by('reg_data', group_id, y, [x1, x2]);
----
true

# TEST 2: Returns correct number of rows (6 per group = 12 total)
query I
SELECT COUNT(*) FROM ols_fit_predict_by('reg_data', group_id, y, [x1, x2]);
----
12

# TEST 3: Has both groups
query I
SELECT COUNT(DISTINCT group_id) FROM ols_fit_predict_by('reg_data', group_id, y, [x1, x2]);
----
2

# TEST 4: Output has correct columns including passthrough source columns
query IIIIIII
SELECT
    group_id IS NOT NULL AS has_group,
    x1 IS NOT NULL OR x1 IS NULL AS has_x1,
    x2 IS NOT NULL AS has_x2,
    y IS NOT NULL OR y IS NULL AS has_y,
    yhat IS NOT NULL AS has_yhat,
    yhat_lower IS NOT NULL OR yhat_lower IS NULL AS has_lower,
    yhat_upper IS NOT NULL OR yhat_upper IS NULL AS has_upper
FROM ols_fit_predict_by('reg_data', group_id, y, [x1, x2])
LIMIT 1;
----
true	true	true	true	true	true	true

# TEST 5: Training rows have y values, OOS rows have NULL y
query II
SELECT
    SUM(CASE WHEN is_training AND y IS NOT NULL THEN 1 ELSE 0 END) AS training_with_y,
    SUM(CASE WHEN NOT is_training AND y IS NULL THEN 1 ELSE 0 END) AS oos_null_y
FROM ols_fit_predict_by('reg_data', group_id, y, [x1, x2]);
----
10	2

# TEST 6: All rows have predictions
query I
SELECT COUNT(*) FROM ols_fit_predict_by('reg_data', group_id, y, [x1, x2]) WHERE yhat IS NOT NULL;
----
12

# TEST 7: Predictions are reasonable (yhat close to y for training data)
query I
SELECT COUNT(*) FROM ols_fit_predict_by('reg_data', group_id, y, [x1, x2])
WHERE is_training AND ABS(yhat - y) < 1.0;
----
10

# TEST 7b: Passthrough columns preserve original values
query IRRR
SELECT COUNT(*) AS n,
    MIN(x1) AS min_x1,
    MAX(x2) AS max_x2,
    SUM(CASE WHEN x1 IS NULL THEN 1 ELSE 0 END) AS null_x1_count
FROM ols_fit_predict_by('reg_data', group_id, y, [x1, x2]);
----
12	1.0	18.0	2

# =============================================================================
# RIDGE_FIT_PREDICT_BY TESTS
# =============================================================================

# TEST 8: Ridge returns results
query I
SELECT COUNT(*) FROM ridge_fit_predict_by('reg_data', group_id, y, [x1, x2]);
----
12

# TEST 9: Ridge predictions are reasonable
query I
SELECT COUNT(*) FROM ridge_fit_predict_by('reg_data', group_id, y, [x1, x2])
WHERE is_training AND ABS(yhat - y) < 2.0;
----
10

# =============================================================================
# ELASTICNET_FIT_PREDICT_BY TESTS
# =============================================================================

# TEST 10: ElasticNet returns results
query I
SELECT COUNT(*) FROM elasticnet_fit_predict_by('reg_data', group_id, y, [x1, x2]);
----
12

# TEST 11: ElasticNet returns correct row count per group
query II
SELECT group_id, COUNT(*) FROM elasticnet_fit_predict_by('reg_data', group_id, y, [x1, x2])
GROUP BY group_id ORDER BY group_id;
----
A	6
B	6

# =============================================================================
# RLS_FIT_PREDICT_BY TESTS
# =============================================================================

# TEST 12: RLS returns results
query I
SELECT COUNT(*) FROM rls_fit_predict_by('reg_data', group_id, y, [x1, x2]);
----
12

# =============================================================================
# BLS_FIT_PREDICT_BY TESTS
# =============================================================================

# TEST 13: BLS returns results
query I
SELECT COUNT(*) FROM bls_fit_predict_by('reg_data', group_id, y, [x1, x2]);
----
12

# =============================================================================
# ALM_FIT_PREDICT_BY TESTS
# =============================================================================

# TEST 14: ALM returns results
query I
SELECT COUNT(*) FROM alm_fit_predict_by('reg_data', group_id, y, [x1, x2]);
----
12

# =============================================================================
# POISSON_FIT_PREDICT_BY TESTS
# =============================================================================

# Create count data for Poisson (using single feature to avoid collinearity)
statement ok
CREATE TABLE count_data AS
SELECT * FROM (VALUES
    ('A', 1.0, 5.0),
    ('A', 2.0, 12.0),
    ('A', 3.0, 25.0),
    ('A', 4.0, 45.0),
    ('A', 5.0, 80.0),
    ('A', NULL, NULL),
    ('B', 1.0, 8.0),
    ('B', 2.0, 20.0),
    ('B', 3.0, 40.0),
    ('B', 4.0, 70.0),
    ('B', 5.0, 120.0),
    ('B', NULL, NULL)
) AS t(group_id, x1, count_y);

# TEST 15: Poisson returns results
query I
SELECT COUNT(*) FROM poisson_fit_predict_by('count_data', group_id, count_y, [x1]);
----
12

# =============================================================================
# WLS_FIT_PREDICT_BY TESTS (requires weight column)
# =============================================================================

statement ok
CREATE TABLE wls_data AS
SELECT * FROM (VALUES
    ('A', 1.0, 2.0, 5.1, 1.0),
    ('A', 2.0, 4.0, 10.2, 1.0),
    ('A', 3.0, 6.0, 15.0, 2.0),
    ('A', 4.0, 8.0, 20.1, 2.0),
    ('A', 5.0, 10.0, 25.0, 3.0),
    ('A', NULL, 12.0, NULL, 3.0),
    ('B', 1.0, 3.0, 8.0, 1.0),
    ('B', 2.0, 6.0, 16.1, 1.0),
    ('B', 3.0, 9.0, 24.0, 2.0),
    ('B', 4.0, 12.0, 32.2, 2.0),
    ('B', 5.0, 15.0, 40.0, 3.0),
    ('B', NULL, 18.0, NULL, 3.0)
) AS t(group_id, x1, x2, y, weight);

# TEST 16: WLS returns results
query I
SELECT COUNT(*) FROM wls_fit_predict_by('wls_data', group_id, y, [x1, x2], weight);
----
12

# =============================================================================
# OPTIONS PARAMETER TESTS
# =============================================================================

# -----------------------------------------------------------------------------
# OLS OPTIONS TESTS
# -----------------------------------------------------------------------------

# TEST 17: OLS with explicit NULL options (backwards compatible)
query I
SELECT COUNT(*) FROM ols_fit_predict_by('reg_data', group_id, y, [x1, x2], NULL);
----
12

# TEST 18: OLS with confidence_level option
query I
SELECT COUNT(*) FROM ols_fit_predict_by('reg_data', group_id, y, [x1, x2], {'confidence_level': 0.99});
----
12

# TEST 19: OLS with fit_intercept option
query I
SELECT COUNT(*) FROM ols_fit_predict_by('reg_data', group_id, y, [x1, x2], {'fit_intercept': true});
----
12

# TEST 20: OLS with null_policy option
query I
SELECT COUNT(*) FROM ols_fit_predict_by('reg_data', group_id, y, [x1, x2], {'null_policy': 'drop'});
----
12

# TEST 21: OLS with multiple options
query I
SELECT COUNT(*) FROM ols_fit_predict_by('reg_data', group_id, y, [x1, x2],
    {'fit_intercept': true, 'confidence_level': 0.90});
----
12

# -----------------------------------------------------------------------------
# RIDGE OPTIONS TESTS
# -----------------------------------------------------------------------------

# TEST 22: Ridge with alpha option
query I
SELECT COUNT(*) FROM ridge_fit_predict_by('reg_data', group_id, y, [x1, x2], {'alpha': 0.5});
----
12

# TEST 23: Ridge with alpha=0 should behave like OLS
query I
SELECT COUNT(*) FROM ridge_fit_predict_by('reg_data', group_id, y, [x1, x2], {'alpha': 0.0});
----
12

# TEST 24: Ridge with high alpha (strong regularization)
query I
SELECT COUNT(*) FROM ridge_fit_predict_by('reg_data', group_id, y, [x1, x2], {'alpha': 10.0});
----
12

# TEST 25: Ridge with alpha and confidence_level
query I
SELECT COUNT(*) FROM ridge_fit_predict_by('reg_data', group_id, y, [x1, x2],
    {'alpha': 1.0, 'confidence_level': 0.99});
----
12

# -----------------------------------------------------------------------------
# ELASTICNET OPTIONS TESTS
# -----------------------------------------------------------------------------

# TEST 26: ElasticNet with alpha option
query I
SELECT COUNT(*) FROM elasticnet_fit_predict_by('reg_data', group_id, y, [x1, x2], {'alpha': 0.1});
----
12

# TEST 27: ElasticNet with l1_ratio option (0 = Ridge, 1 = Lasso)
query I
SELECT COUNT(*) FROM elasticnet_fit_predict_by('reg_data', group_id, y, [x1, x2], {'l1_ratio': 0.5});
----
12

# TEST 28: ElasticNet with alpha and l1_ratio
query I
SELECT COUNT(*) FROM elasticnet_fit_predict_by('reg_data', group_id, y, [x1, x2],
    {'alpha': 0.1, 'l1_ratio': 0.7});
----
12

# TEST 29: ElasticNet with max_iterations and tolerance
query I
SELECT COUNT(*) FROM elasticnet_fit_predict_by('reg_data', group_id, y, [x1, x2],
    {'max_iterations': 500, 'tolerance': 1e-5});
----
12

# -----------------------------------------------------------------------------
# WLS OPTIONS TESTS
# -----------------------------------------------------------------------------

# TEST 30: WLS with explicit NULL options
query I
SELECT COUNT(*) FROM wls_fit_predict_by('wls_data', group_id, y, [x1, x2], weight, NULL);
----
12

# TEST 31: WLS with confidence_level option
query I
SELECT COUNT(*) FROM wls_fit_predict_by('wls_data', group_id, y, [x1, x2], weight,
    {'confidence_level': 0.95});
----
12

# TEST 32: WLS with fit_intercept option
query I
SELECT COUNT(*) FROM wls_fit_predict_by('wls_data', group_id, y, [x1, x2], weight,
    {'fit_intercept': true});
----
12

# -----------------------------------------------------------------------------
# RLS OPTIONS TESTS
# -----------------------------------------------------------------------------

# TEST 33: RLS with forgetting_factor option
query I
SELECT COUNT(*) FROM rls_fit_predict_by('reg_data', group_id, y, [x1, x2],
    {'forgetting_factor': 0.99});
----
12

# TEST 34: RLS with forgetting_factor = 1.0 (no forgetting)
query I
SELECT COUNT(*) FROM rls_fit_predict_by('reg_data', group_id, y, [x1, x2],
    {'forgetting_factor': 1.0});
----
12

# TEST 35: RLS with initial_p_diagonal option
query I
SELECT COUNT(*) FROM rls_fit_predict_by('reg_data', group_id, y, [x1, x2],
    {'initial_p_diagonal': 100.0});
----
12

# TEST 36: RLS with multiple options
query I
SELECT COUNT(*) FROM rls_fit_predict_by('reg_data', group_id, y, [x1, x2],
    {'forgetting_factor': 0.95, 'initial_p_diagonal': 50.0});
----
12

# -----------------------------------------------------------------------------
# BLS OPTIONS TESTS
# -----------------------------------------------------------------------------

# TEST 37: BLS with lower_bound option (non-negative coefficients)
query I
SELECT COUNT(*) FROM bls_fit_predict_by('reg_data', group_id, y, [x1, x2],
    {'lower_bound': 0.0});
----
12

# TEST 38: BLS with upper_bound option
query I
SELECT COUNT(*) FROM bls_fit_predict_by('reg_data', group_id, y, [x1, x2],
    {'upper_bound': 10.0});
----
12

# TEST 39: BLS with both bounds (box constraints)
query I
SELECT COUNT(*) FROM bls_fit_predict_by('reg_data', group_id, y, [x1, x2],
    {'lower_bound': 0.0, 'upper_bound': 5.0});
----
12

# TEST 40: BLS with intercept option
query I
SELECT COUNT(*) FROM bls_fit_predict_by('reg_data', group_id, y, [x1, x2],
    {'intercept': true});
----
12

# -----------------------------------------------------------------------------
# ALM OPTIONS TESTS
# -----------------------------------------------------------------------------

# TEST 41: ALM with normal distribution (default)
query I
SELECT COUNT(*) FROM alm_fit_predict_by('reg_data', group_id, y, [x1, x2],
    {'distribution': 'normal'});
----
12

# TEST 42: ALM with laplace distribution (robust regression)
query I
SELECT COUNT(*) FROM alm_fit_predict_by('reg_data', group_id, y, [x1, x2],
    {'distribution': 'laplace'});
----
12

# TEST 43: ALM with studentt distribution
query I
SELECT COUNT(*) FROM alm_fit_predict_by('reg_data', group_id, y, [x1, x2],
    {'distribution': 'studentt'});
----
12

# TEST 44: ALM with max_iterations and tolerance
query I
SELECT COUNT(*) FROM alm_fit_predict_by('reg_data', group_id, y, [x1, x2],
    {'distribution': 'laplace', 'max_iterations': 200, 'tolerance': 1e-6});
----
12

# -----------------------------------------------------------------------------
# POISSON OPTIONS TESTS
# -----------------------------------------------------------------------------

# TEST 45: Poisson with log link (default)
query I
SELECT COUNT(*) FROM poisson_fit_predict_by('count_data', group_id, count_y, [x1],
    {'link': 'log'});
----
12

# TEST 46: Poisson with identity link
query I
SELECT COUNT(*) FROM poisson_fit_predict_by('count_data', group_id, count_y, [x1],
    {'link': 'identity'});
----
12

# TEST 47: Poisson with sqrt link
query I
SELECT COUNT(*) FROM poisson_fit_predict_by('count_data', group_id, count_y, [x1],
    {'link': 'sqrt'});
----
12

# TEST 48: Poisson with max_iterations option
query I
SELECT COUNT(*) FROM poisson_fit_predict_by('count_data', group_id, count_y, [x1],
    {'max_iterations': 50});
----
12

# TEST 49: Poisson with intercept option
query I
SELECT COUNT(*) FROM poisson_fit_predict_by('count_data', group_id, count_y, [x1],
    {'intercept': true, 'link': 'log'});
----
12

# -----------------------------------------------------------------------------
# VERIFY OPTIONS AFFECT RESULTS
# -----------------------------------------------------------------------------

# TEST 50: Ridge predictions change with different alpha values
# Higher alpha = more regularization = predictions closer to mean
query I
SELECT
    (SELECT AVG(ABS(yhat - y)) FROM ridge_fit_predict_by('reg_data', group_id, y, [x1, x2],
        {'alpha': 0.01}) WHERE is_training) <
    (SELECT AVG(ABS(yhat - y)) FROM ridge_fit_predict_by('reg_data', group_id, y, [x1, x2],
        {'alpha': 100.0}) WHERE is_training);
----
true

# =============================================================================
# SPLIT PARAMETER TESTS
# =============================================================================

# Create data with explicit split column
statement ok
CREATE TABLE split_data AS
SELECT *, CASE WHEN y IS NOT NULL THEN 'train' ELSE 'test' END AS split
FROM reg_data;

# TEST 51: Split parameter produces same row count
query I
SELECT COUNT(*) FROM ols_fit_predict_by('split_data', group_id, y, [x1, x2], split := split);
----
12

# TEST 52: Split parameter correctly identifies training rows
query II
SELECT
    SUM(CASE WHEN is_training THEN 1 ELSE 0 END) AS train_count,
    SUM(CASE WHEN NOT is_training THEN 1 ELSE 0 END) AS test_count
FROM ols_fit_predict_by('split_data', group_id, y, [x1, x2], split := split);
----
10	2

# TEST 53: Split results match NULL-y approach (same predictions per group)
query I
SELECT COUNT(*) FROM (
    SELECT a.group_id, ABS(a.sum_yhat - b.sum_yhat) < 1e-8 AS match
    FROM (SELECT group_id, SUM(yhat) AS sum_yhat FROM ols_fit_predict_by('reg_data', group_id, y, [x1, x2]) GROUP BY group_id) a
    JOIN (SELECT group_id, SUM(yhat) AS sum_yhat FROM ols_fit_predict_by('split_data', group_id, y, [x1, x2], split := split) GROUP BY group_id) b
    ON a.group_id = b.group_id
    WHERE match
);
----
2

# TEST 54: Without split parameter, backward compatible (same as before)
query I
SELECT COUNT(*) FROM ols_fit_predict_by('split_data', group_id, y, [x1, x2]);
----
12

# TEST 55: Split with options
query I
SELECT COUNT(*) FROM ols_fit_predict_by('split_data', group_id, y, [x1, x2],
    options := {'confidence_level': 0.99}, split := split);
----
12

# =============================================================================
# CLEANUP
# =============================================================================

statement ok
DROP TABLE IF EXISTS split_data;

statement ok
DROP TABLE IF EXISTS reg_data;

statement ok
DROP TABLE IF EXISTS count_data;

statement ok
DROP TABLE IF EXISTS wls_data;
