# name: test/sql/fit_predict_agg/test_isotonic_fit_predict_agg.test
# description: Test Isotonic fit_predict_agg aggregate function
# group: [fit_predict_agg]

require anofox_statistics

# =============================================================================
# SETUP: Create test data with monotonic-ish pattern
# =============================================================================

statement ok
CREATE TABLE test_data AS
SELECT
    CASE WHEN i <= 7 THEN
        CASE i
            WHEN 1 THEN 1.0
            WHEN 2 THEN 3.0
            WHEN 3 THEN 2.0
            WHEN 4 THEN 5.0
            WHEN 5 THEN 4.0
            WHEN 6 THEN 7.0
            WHEN 7 THEN 8.0
        END
    ELSE NULL END AS y,
    i::DOUBLE AS x,
    i AS id
FROM range(1, 11) t(i);

# =============================================================================
# TEST 1: Basic Fit and Predict - Returns correct number of rows
# =============================================================================

query I
SELECT LENGTH(isotonic_fit_predict_agg(y, x)) AS n_rows FROM test_data;
----
10

# =============================================================================
# TEST 2: Training vs Prediction Row Identification
# =============================================================================

query II
SELECT
    SUM(CASE WHEN (pred).is_training THEN 1 ELSE 0 END) AS n_training,
    SUM(CASE WHEN NOT (pred).is_training THEN 1 ELSE 0 END) AS n_prediction
FROM (
    SELECT UNNEST(isotonic_fit_predict_agg(y, x)) AS pred
    FROM test_data
);
----
7	3

# =============================================================================
# TEST 3: Monotonic Constraint is Enforced
# - For increasing=true (default), yhat should never decrease as x increases
# =============================================================================

query I
SELECT COUNT(*) FROM (
    SELECT
        (pred).x AS x_val,
        (pred).yhat AS yhat_val,
        LAG((pred).yhat) OVER (ORDER BY (pred).x) AS prev_yhat
    FROM (
        SELECT UNNEST(isotonic_fit_predict_agg(y, x)) AS pred
        FROM test_data
    )
)
WHERE prev_yhat IS NOT NULL AND yhat_val < prev_yhat;
----
0

# =============================================================================
# TEST 4: Configuration Options - increasing=false
# =============================================================================

statement ok
CREATE TABLE decreasing_data AS
SELECT
    CASE WHEN i <= 7 THEN (20.0 - i * 2.0 + (CASE WHEN i = 3 THEN 3.0 ELSE 0.0 END)) ELSE NULL END AS y,
    i::DOUBLE AS x,
    i AS id
FROM range(1, 11) t(i);

query I
SELECT LENGTH(isotonic_fit_predict_agg(y, x, {'increasing': false})) FROM decreasing_data;
----
10

# Verify decreasing constraint is enforced
query I
SELECT COUNT(*) FROM (
    SELECT
        (pred).x AS x_val,
        (pred).yhat AS yhat_val,
        LAG((pred).yhat) OVER (ORDER BY (pred).x) AS prev_yhat
    FROM (
        SELECT UNNEST(isotonic_fit_predict_agg(y, x, {'increasing': false})) AS pred
        FROM decreasing_data
    )
)
WHERE prev_yhat IS NOT NULL AND yhat_val > prev_yhat;
----
0

# =============================================================================
# TEST 5: GROUP BY Partitioning
# =============================================================================

statement ok
CREATE TABLE grouped_data AS
SELECT
    CASE WHEN i <= 5 THEN 'A' ELSE 'B' END AS grp,
    CASE WHEN i <= 4 OR (i > 5 AND i <= 9) THEN (i::DOUBLE * 2.0) ELSE NULL END AS y,
    (CASE WHEN i <= 5 THEN i ELSE i - 5 END)::DOUBLE AS x,
    i AS id
FROM range(1, 11) t(i);

query TI
SELECT grp, LENGTH(isotonic_fit_predict_agg(y, x)) AS n_rows
FROM grouped_data
GROUP BY grp
ORDER BY grp;
----
A	5
B	5

# =============================================================================
# TEST 6: Multiple Groups with Different IDs
# =============================================================================

statement ok
CREATE TABLE multi_group_data AS
SELECT
    category,
    product_id,
    CASE WHEN row_num <= 4 THEN sales ELSE NULL END AS y,
    price AS x
FROM (
    SELECT
        CASE WHEN i <= 6 THEN 'Electronics' ELSE 'Clothing' END AS category,
        i AS product_id,
        (i * 10.0)::DOUBLE AS sales,
        (i * 5.0)::DOUBLE AS price,
        ROW_NUMBER() OVER (PARTITION BY (CASE WHEN i <= 6 THEN 'Electronics' ELSE 'Clothing' END) ORDER BY i) AS row_num
    FROM range(1, 13) t(i)
);

query TI
SELECT category, LENGTH(isotonic_fit_predict_agg(y, x)) AS n_rows
FROM multi_group_data
GROUP BY category
ORDER BY category;
----
Clothing	6
Electronics	6

# =============================================================================
# TEST 7: Interpolation for Prediction Points
# =============================================================================

query I
SELECT COUNT(*) FROM (
    SELECT UNNEST(isotonic_fit_predict_agg(y, x)) AS pred
    FROM test_data
)
WHERE NOT (pred).is_training AND (pred).yhat IS NOT NULL;
----
3

# =============================================================================
# TEST 8: Original Values Preserved
# =============================================================================

query I
SELECT COUNT(*) FROM (
    SELECT UNNEST(isotonic_fit_predict_agg(y, x)) AS pred
    FROM test_data
)
WHERE (pred).x IS NOT NULL;
----
10

# =============================================================================
# TEST 9: Insufficient Data Handling
# =============================================================================

query I
SELECT LENGTH(isotonic_fit_predict_agg(y, x)) FROM (SELECT * FROM test_data LIMIT 1);
----
NULL

# =============================================================================
# TEST 10: All Training Rows (No Predictions)
# =============================================================================

statement ok
CREATE TABLE all_training AS
SELECT (i * 2.0) AS y, i::DOUBLE AS x, i AS id
FROM range(1, 11) t(i);

query II
SELECT
    SUM(CASE WHEN (pred).is_training THEN 1 ELSE 0 END) AS n_training,
    SUM(CASE WHEN NOT (pred).is_training THEN 1 ELSE 0 END) AS n_prediction
FROM (
    SELECT UNNEST(isotonic_fit_predict_agg(y, x)) AS pred
    FROM all_training
);
----
10	0

# =============================================================================
# TEST 11: All Prediction Rows (No Training) - Should return NULL
# =============================================================================

statement ok
CREATE TABLE all_prediction AS
SELECT NULL::DOUBLE AS y, i::DOUBLE AS x, i AS id
FROM range(1, 11) t(i);

query I
SELECT isotonic_fit_predict_agg(y, x) IS NULL FROM all_prediction;
----
true

# =============================================================================
# TEST 12: Perfect Monotonic Data
# =============================================================================

statement ok
CREATE TABLE perfect_monotonic AS
SELECT
    CASE WHEN i <= 8 THEN (i * 3.0) ELSE NULL END AS y,
    i::DOUBLE AS x,
    i AS id
FROM range(1, 11) t(i);

query I
SELECT LENGTH(isotonic_fit_predict_agg(y, x)) FROM perfect_monotonic;
----
10

# =============================================================================
# TEST 13: Extrapolation Beyond Training Range
# =============================================================================

statement ok
CREATE TABLE extrap_data AS
SELECT
    CASE WHEN i >= 3 AND i <= 7 THEN (i * 2.0) ELSE NULL END AS y,
    i::DOUBLE AS x,
    i AS id
FROM range(1, 11) t(i);

query I
SELECT COUNT(*) FROM (
    SELECT UNNEST(isotonic_fit_predict_agg(y, x)) AS pred
    FROM extrap_data
)
WHERE (pred).yhat IS NOT NULL;
----
10

# =============================================================================
# TEST 14: Larger Dataset
# =============================================================================

statement ok
CREATE TABLE large_data AS
SELECT
    CASE WHEN i <= 80 THEN (i * 2.0 + (i % 5)) ELSE NULL END AS y,
    i::DOUBLE AS x,
    i AS id
FROM range(1, 101) t(i);

query I
SELECT LENGTH(isotonic_fit_predict_agg(y, x)) FROM large_data;
----
100

# =============================================================================
# TEST 15: Ties in X Values
# =============================================================================

statement ok
CREATE TABLE ties_data AS
SELECT
    CASE WHEN i <= 6 THEN (i * 2.0) ELSE NULL END AS y,
    FLOOR(i / 2.0)::DOUBLE AS x,
    i AS id
FROM range(1, 9) t(i);

query I
SELECT LENGTH(isotonic_fit_predict_agg(y, x)) FROM ties_data;
----
8

# =============================================================================
# CLEANUP
# =============================================================================

statement ok
DROP TABLE IF EXISTS test_data;

statement ok
DROP TABLE IF EXISTS decreasing_data;

statement ok
DROP TABLE IF EXISTS grouped_data;

statement ok
DROP TABLE IF EXISTS multi_group_data;

statement ok
DROP TABLE IF EXISTS all_training;

statement ok
DROP TABLE IF EXISTS all_prediction;

statement ok
DROP TABLE IF EXISTS perfect_monotonic;

statement ok
DROP TABLE IF EXISTS extrap_data;

statement ok
DROP TABLE IF EXISTS large_data;

statement ok
DROP TABLE IF EXISTS ties_data;
