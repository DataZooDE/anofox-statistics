# name: test/sql/fit_predict_agg/test_quantile_fit_predict_agg.test
# description: Test Quantile fit_predict_agg aggregate function
# group: [fit_predict_agg]

require anofox_statistics

# =============================================================================
# SETUP: Create test data
# =============================================================================

statement ok
CREATE TABLE test_data AS
SELECT
    CASE WHEN i <= 7 THEN (2.0 * i + 1.0 + (i % 3) - 1.0) ELSE NULL END AS y,
    i::DOUBLE AS x1,
    (i * 0.5)::DOUBLE AS x2,
    i AS id
FROM range(1, 11) t(i);

# =============================================================================
# TEST 1: Basic Fit and Predict - Returns correct number of rows
# =============================================================================

query I
SELECT LENGTH(quantile_fit_predict_agg(y, [x1, x2])) AS n_rows FROM test_data;
----
10

# =============================================================================
# TEST 2: Training vs Prediction Row Identification
# =============================================================================

query II
SELECT
    SUM(CASE WHEN (pred).is_training THEN 1 ELSE 0 END) AS n_training,
    SUM(CASE WHEN NOT (pred).is_training THEN 1 ELSE 0 END) AS n_prediction
FROM (
    SELECT UNNEST(quantile_fit_predict_agg(y, [x1, x2])) AS pred
    FROM test_data
);
----
7	3

# =============================================================================
# TEST 3: Predictions Are Reasonable
# =============================================================================

query I
SELECT COUNT(*) FROM (
    SELECT UNNEST(quantile_fit_predict_agg(y, [x1, x2])) AS pred
    FROM test_data
)
WHERE (pred).yhat IS NOT NULL;
----
10

# =============================================================================
# TEST 4: Configuration Options - Different tau values
# =============================================================================

query I
SELECT LENGTH(quantile_fit_predict_agg(y, [x1, x2], {'tau': 0.25})) FROM test_data;
----
10

query I
SELECT LENGTH(quantile_fit_predict_agg(y, [x1, x2], {'tau': 0.5})) FROM test_data;
----
10

query I
SELECT LENGTH(quantile_fit_predict_agg(y, [x1, x2], {'tau': 0.75})) FROM test_data;
----
10

query I
SELECT LENGTH(quantile_fit_predict_agg(y, [x1, x2], {'tau': 0.9})) FROM test_data;
----
10

# =============================================================================
# TEST 5: GROUP BY Partitioning
# =============================================================================

statement ok
CREATE TABLE grouped_data AS
SELECT
    CASE WHEN i <= 5 THEN 'A' ELSE 'B' END AS grp,
    CASE WHEN i <= 4 OR (i > 5 AND i <= 9) THEN (i::DOUBLE * 2.0 + (i % 3)) ELSE NULL END AS y,
    i::DOUBLE AS x1,
    (i * 0.5)::DOUBLE AS x2,
    i AS id
FROM range(1, 11) t(i);

query TI
SELECT grp, LENGTH(quantile_fit_predict_agg(y, [x1, x2])) AS n_rows
FROM grouped_data
GROUP BY grp
ORDER BY grp;
----
A	5
B	5

# =============================================================================
# TEST 6: Multiple Groups with Different IDs
# =============================================================================

statement ok
CREATE TABLE multi_group_data AS
SELECT
    category,
    product_id,
    CASE WHEN row_num <= 4 THEN sales ELSE NULL END AS y,
    price AS x1,
    quantity AS x2
FROM (
    SELECT
        CASE WHEN i <= 6 THEN 'Electronics' ELSE 'Clothing' END AS category,
        i AS product_id,
        (100 + i * 10 + (i % 5))::DOUBLE AS sales,
        (50 + i * 5)::DOUBLE AS price,
        (10 + i)::DOUBLE AS quantity,
        ROW_NUMBER() OVER (PARTITION BY (CASE WHEN i <= 6 THEN 'Electronics' ELSE 'Clothing' END) ORDER BY i) AS row_num
    FROM range(1, 13) t(i)
);

query TI
SELECT category, LENGTH(quantile_fit_predict_agg(y, [x1, x2])) AS n_rows
FROM multi_group_data
GROUP BY category
ORDER BY category;
----
Clothing	6
Electronics	6

# =============================================================================
# TEST 7: Original Values Preserved
# =============================================================================

query I
SELECT COUNT(*) FROM (
    SELECT UNNEST(quantile_fit_predict_agg(y, [x1, x2])) AS pred
    FROM test_data
)
WHERE (pred).x IS NOT NULL AND LENGTH((pred).x) = 2;
----
10

# =============================================================================
# TEST 8: fit_intercept Option
# =============================================================================

query I
SELECT LENGTH(quantile_fit_predict_agg(y, [x1, x2], {'fit_intercept': false})) FROM test_data;
----
10

# =============================================================================
# TEST 9: Combined Options - tau and fit_intercept
# =============================================================================

query I
SELECT LENGTH(quantile_fit_predict_agg(y, [x1, x2], {'tau': 0.75, 'fit_intercept': true})) FROM test_data;
----
10

# =============================================================================
# TEST 10: Insufficient Data Handling
# =============================================================================

query I
SELECT LENGTH(quantile_fit_predict_agg(y, [x1, x2])) FROM (SELECT * FROM test_data LIMIT 2);
----
NULL

# =============================================================================
# TEST 11: All Training Rows (No Predictions)
# =============================================================================

statement ok
CREATE TABLE all_training AS
SELECT (2.0 * i + 1.0 + (i % 3)) AS y, i::DOUBLE AS x1, (i * 0.5)::DOUBLE AS x2, i AS id
FROM range(1, 11) t(i);

query II
SELECT
    SUM(CASE WHEN (pred).is_training THEN 1 ELSE 0 END) AS n_training,
    SUM(CASE WHEN NOT (pred).is_training THEN 1 ELSE 0 END) AS n_prediction
FROM (
    SELECT UNNEST(quantile_fit_predict_agg(y, [x1, x2])) AS pred
    FROM all_training
);
----
10	0

# =============================================================================
# TEST 12: All Prediction Rows (No Training) - Should return NULL
# =============================================================================

statement ok
CREATE TABLE all_prediction AS
SELECT NULL::DOUBLE AS y, i::DOUBLE AS x1, (i * 0.5)::DOUBLE AS x2, i AS id
FROM range(1, 11) t(i);

query I
SELECT quantile_fit_predict_agg(y, [x1, x2]) IS NULL FROM all_prediction;
----
true

# =============================================================================
# TEST 13: Single Feature
# =============================================================================

query I
SELECT LENGTH(quantile_fit_predict_agg(y, [x1])) FROM test_data;
----
10

# =============================================================================
# TEST 14: High-Dimensional Data (Many Features)
# =============================================================================

statement ok
CREATE TABLE high_dim AS
SELECT
    CASE WHEN i <= 20 THEN (i * 1.5 + (i % 4)) ELSE NULL END AS y,
    i::DOUBLE AS x1,
    (i * 2)::DOUBLE AS x2,
    (i * 3)::DOUBLE AS x3,
    (i * 4)::DOUBLE AS x4,
    (i * 5)::DOUBLE AS x5,
    i AS id
FROM range(1, 26) t(i);

query I
SELECT LENGTH(quantile_fit_predict_agg(y, [x1, x2, x3, x4, x5])) FROM high_dim;
----
25

# =============================================================================
# TEST 15: Larger Dataset
# =============================================================================

statement ok
CREATE TABLE large_data AS
SELECT
    CASE WHEN i <= 80 THEN (2.0 * i + 1.0 + (i % 7)) ELSE NULL END AS y,
    i::DOUBLE AS x1,
    (i * 0.5)::DOUBLE AS x2,
    i AS id
FROM range(1, 101) t(i);

query I
SELECT LENGTH(quantile_fit_predict_agg(y, [x1, x2])) FROM large_data;
----
100

# =============================================================================
# TEST 16: Different tau Values Produce Different Predictions
# - Higher tau should generally produce higher predictions
# =============================================================================

query I
SELECT (
    SELECT AVG((pred).yhat)
    FROM (SELECT UNNEST(quantile_fit_predict_agg(y, [x1], {'tau': 0.9})) AS pred FROM test_data)
) > (
    SELECT AVG((pred).yhat)
    FROM (SELECT UNNEST(quantile_fit_predict_agg(y, [x1], {'tau': 0.1})) AS pred FROM test_data)
) AS higher_tau_higher_pred;
----
true

# =============================================================================
# TEST 17: Data with Outliers
# =============================================================================

statement ok
CREATE TABLE outlier_data AS
SELECT
    CASE
        WHEN i = 5 THEN 1000.0
        WHEN i <= 8 THEN (2.0 * i)
        ELSE NULL
    END AS y,
    i::DOUBLE AS x1,
    i AS id
FROM range(1, 11) t(i);

query I
SELECT COUNT(*) FILTER (WHERE (pred).yhat IS NOT NULL)
FROM (
    SELECT UNNEST(quantile_fit_predict_agg(y, [x1])) AS pred
    FROM outlier_data
);
----
10

# =============================================================================
# TEST 18: Extreme Quantiles
# =============================================================================

query I
SELECT LENGTH(quantile_fit_predict_agg(y, [x1], {'tau': 0.01})) FROM test_data;
----
10

query I
SELECT LENGTH(quantile_fit_predict_agg(y, [x1], {'tau': 0.99})) FROM test_data;
----
10

# =============================================================================
# CLEANUP
# =============================================================================

statement ok
DROP TABLE IF EXISTS test_data;

statement ok
DROP TABLE IF EXISTS grouped_data;

statement ok
DROP TABLE IF EXISTS multi_group_data;

statement ok
DROP TABLE IF EXISTS all_training;

statement ok
DROP TABLE IF EXISTS all_prediction;

statement ok
DROP TABLE IF EXISTS high_dim;

statement ok
DROP TABLE IF EXISTS large_data;

statement ok
DROP TABLE IF EXISTS outlier_data;
