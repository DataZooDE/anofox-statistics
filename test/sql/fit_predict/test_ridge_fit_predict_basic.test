# name: test/sql/fit_predict/test_ridge_fit_predict_basic.test
# description: Test basic Ridge fit-predict functionality
# group: [fit_predict]

require anofox_statistics

# Test 1: Ridge fit-predict with regularization
statement ok
CREATE TABLE ridge_data AS
SELECT
    CASE WHEN i <= 6 THEN (i * 2.0 + 1.0)::DOUBLE ELSE NULL END as y,
    i::DOUBLE as x1,
    (i * 0.5)::DOUBLE as x2,
    i as id
FROM range(1, 11) t(i);

# Test 2: Basic Ridge fit-predict with lambda=1.0
query II
SELECT
    id,
    ROUND((pred).yhat, 2) as yhat
FROM (
    SELECT
        id,
        anofox_statistics_fit_predict_ridge(
            y,
            [x1],
            MAP{'intercept': true, 'lambda': 1.0}
        ) OVER () as pred
    FROM ridge_data
)
ORDER BY id;
----
1	2.85
2	4.77
3	6.68
4	8.60
5	10.51
6	12.43
7	14.34
8	16.26
9	18.17
10	20.09

# Test 3: Ridge vs OLS (Ridge should have smaller coefficients due to regularization)
# Compare on a dataset with multicollinearity
statement ok
CREATE TABLE collinear_data AS
SELECT
    CASE WHEN i <= 8 THEN (3.0 * x + random() * 0.5)::DOUBLE ELSE NULL END as y,
    i::DOUBLE as x,
    (i + random() * 0.1)::DOUBLE as x_corr,  -- Highly correlated with x
    i as id
FROM range(1, 13) t(i);

# Ridge with high lambda should produce more conservative predictions
query I
SELECT
    COUNT(*) as predictions_in_range
FROM (
    SELECT
        id,
        (ridge_pred).yhat as ridge_yhat,
        (ols_pred).yhat as ols_yhat
    FROM (
        SELECT
            id,
            anofox_statistics_fit_predict_ridge(
                y,
                [x, x_corr],
                MAP{'intercept': true, 'lambda': 10.0}
            ) OVER () as ridge_pred,
            anofox_statistics_fit_predict_ols(
                y,
                [x, x_corr],
                MAP{'intercept': true}
            ) OVER () as ols_pred
        FROM collinear_data
    )
    WHERE id > 8  -- Prediction rows
)
WHERE ridge_yhat BETWEEN 20 AND 40  -- Should be reasonable
----
4

# Test 4: Ridge with PARTITION BY
statement ok
CREATE TABLE ridge_groups AS
SELECT
    CASE WHEN i <= 3 THEN (i * group_id_num + 1.0)::DOUBLE ELSE NULL END as y,
    i::DOUBLE as x,
    group_id,
    group_id_num,
    i as row_id
FROM range(1, 7) t(i),
     (VALUES ('A', 1), ('B', 2)) g(group_id, group_id_num);

query III
SELECT
    group_id,
    row_id,
    ROUND((pred).yhat, 1) as yhat
FROM (
    SELECT
        group_id,
        row_id,
        anofox_statistics_fit_predict_ridge(
            y,
            [x],
            MAP{'intercept': true, 'lambda': 0.5}
        ) OVER (PARTITION BY group_id) as pred
    FROM ridge_groups
)
ORDER BY group_id, row_id;
----
A	1	1.9
A	2	2.8
A	3	3.7
A	4	4.6
A	5	5.5
A	6	6.4
B	1	2.8
B	2	4.7
B	3	6.6
B	4	8.5
B	5	10.4
B	6	12.3

# Cleanup
statement ok
DROP TABLE ridge_data;

statement ok
DROP TABLE collinear_data;

statement ok
DROP TABLE ridge_groups;
