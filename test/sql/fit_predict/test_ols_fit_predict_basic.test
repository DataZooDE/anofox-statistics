# name: test/sql/fit_predict/test_ols_fit_predict_basic.test
# description: Test basic OLS fit-predict functionality
# group: [fit_predict]

require anofox_statistics

# Test 1: Simple fit-predict with train/test split
statement ok
CREATE TABLE train_test_data AS
SELECT
    CASE WHEN i <= 5 THEN i::DOUBLE ELSE NULL END as y,
    i::DOUBLE as x1,
    (i * 2)::DOUBLE as x2,
    i as id
FROM range(1, 11) t(i);

# Verify we have 5 training rows and 5 prediction rows
query I
SELECT COUNT(*) FROM train_test_data WHERE y IS NOT NULL;
----
5

query I
SELECT COUNT(*) FROM train_test_data WHERE y IS NULL;
----
5

# Test 2: Basic OLS fit-predict over entire dataset
query IIII
SELECT
    id,
    ROUND((pred).yhat, 2) as yhat,
    ROUND((pred).yhat_lower, 2) as lower,
    ROUND((pred).yhat_upper, 2) as upper
FROM (
    SELECT
        id,
        anofox_statistics_fit_predict_ols(
            y,
            [x1],
            MAP{'intercept': 1}
        ) OVER () as pred
    FROM train_test_data
)
ORDER BY id;
----
1	1.0	-0.27	2.27
2	2.0	0.91	3.09
3	3.0	1.94	4.06
4	4.0	2.73	5.27
5	5.0	3.73	6.27
6	6.0	4.73	7.27
7	7.0	5.73	8.27
8	8.0	6.73	9.27
9	9.0	7.73	10.27
10	10.0	8.73	11.27

# Test 3: OLS fit-predict with PARTITION BY
statement ok
CREATE TABLE grouped_data AS
SELECT
    CASE WHEN i <= 3 THEN (i + group_id)::DOUBLE ELSE NULL END as y,
    i::DOUBLE as x,
    group_id,
    i as row_id
FROM range(1, 7) t(i), (VALUES ('A'), ('B')) g(group_id);

# Each group should have its own model
query III
SELECT
    group_id,
    row_id,
    ROUND((pred).yhat, 2) as yhat
FROM (
    SELECT
        group_id,
        row_id,
        anofox_statistics_fit_predict_ols(
            y,
            [x],
            MAP{'intercept': true}
        ) OVER (PARTITION BY group_id) as pred
    FROM grouped_data
)
ORDER BY group_id, row_id;
----
A	1	2.0
A	2	3.0
A	3	4.0
A	4	5.0
A	5	6.0
A	6	7.0
B	1	2.0
B	2	3.0
B	3	4.0
B	4	5.0
B	5	6.0
B	6	7.0

# Test 4: Multi-feature OLS fit-predict
statement ok
CREATE TABLE multi_feature AS
SELECT
    CASE WHEN i <= 8 THEN (2.0 * x1 + 3.0 * x2 + 1.0 + (random() * 0.1))::DOUBLE ELSE NULL END as y,
    i::DOUBLE as x1,
    (i * 0.5)::DOUBLE as x2,
    i as id
FROM range(1, 13) t(i);

# Should predict reasonably well (coefficients near 2 and 3)
query II
SELECT
    id,
    ROUND((pred).yhat, 1) as yhat
FROM (
    SELECT
        id,
        anofox_statistics_fit_predict_ols(
            y,
            [x1, x2],
            MAP{'intercept': true}
        ) OVER () as pred
    FROM multi_feature
)
WHERE id IN (9, 10, 11, 12)
ORDER BY id;
----
9	24.5
10	27.0
11	29.5
12	32.0

# Cleanup
statement ok
DROP TABLE train_test_data;

statement ok
DROP TABLE grouped_data;

statement ok
DROP TABLE multi_feature;
