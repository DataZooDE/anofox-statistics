# name: test/sql/fit_predict/test_ridge_fit_predict_edge.test
# description: Test edge cases for Ridge fit-predict
# group: [fit_predict]

require anofox_statistics

# Test 1: Insufficient training data (less than p+1 observations)
statement ok
CREATE TABLE ridge_insufficient AS
SELECT
    i as id,
    i::DOUBLE as x1,
    (i * 0.5)::DOUBLE as x2,
    CASE WHEN i <= 2 THEN (i * 2.0)::DOUBLE ELSE NULL END as y  -- Only 2 training rows for 2 features
FROM range(1, 6) t(i);

query I
SELECT
    COUNT(*) as null_predictions
FROM (
    SELECT
        id,
        anofox_stats_ridge_fit_predict(
            y,
            [x1, x2],
            MAP{'intercept': 1, 'lambda': 1.0}
        ) OVER (ORDER BY id) as pred
    FROM ridge_insufficient
)
WHERE (pred).yhat IS NULL;
----
0

# Test 2: All NULL y values
statement ok
CREATE TABLE ridge_all_null AS
SELECT
    i as id,
    i::DOUBLE as x,
    NULL::DOUBLE as y
FROM range(1, 8) t(i);

query I
SELECT
    COUNT(*) as null_predictions
FROM (
    SELECT
        id,
        anofox_stats_ridge_fit_predict(
            y,
            [x],
            MAP{'intercept': 1, 'lambda': 1.0}
        ) OVER (ORDER BY id) as pred
    FROM ridge_all_null
)
WHERE (pred).yhat IS NULL;
----
0

# Test 3: Empty feature array
statement ok
CREATE TABLE ridge_empty_features AS
SELECT
    i as id,
    CASE WHEN i <= 4 THEN (i * 2.0)::DOUBLE ELSE NULL END as y,
    []::DOUBLE[] as x_empty
FROM range(1, 7) t(i);

query I
SELECT
    COUNT(*) as null_predictions
FROM (
    SELECT
        id,
        anofox_stats_ridge_fit_predict(
            y,
            x_empty,
            MAP{'intercept': 1, 'lambda': 1.0}
        ) OVER (ORDER BY id) as pred
    FROM ridge_empty_features
)
WHERE (pred).yhat IS NULL;
----
0

# Test 4: NULL values in feature arrays
statement ok
CREATE TABLE ridge_null_features AS
SELECT
    i as id,
    CASE WHEN i <= 5 THEN (i * 2.0)::DOUBLE ELSE NULL END as y,
    CASE WHEN i % 2 = 0 THEN [i::DOUBLE, NULL] ELSE [i::DOUBLE, (i * 0.5)::DOUBLE] END as x
FROM range(1, 9) t(i);

query I
SELECT
    COUNT(*) as has_predictions
FROM (
    SELECT
        id,
        anofox_stats_ridge_fit_predict(
            y,
            x,
            MAP{'intercept': 1, 'lambda': 1.0}
        ) OVER (ORDER BY id) as pred
    FROM ridge_null_features
)
WHERE (pred).yhat IS NOT NULL;
----
8

# Test 5: Inconsistent feature array lengths
statement ok
CREATE TABLE ridge_inconsistent_features AS
SELECT
    i as id,
    CASE WHEN i <= 5 THEN (i * 2.0)::DOUBLE ELSE NULL END as y,
    CASE WHEN i = 1 THEN [i::DOUBLE] ELSE [i::DOUBLE, (i * 0.5)::DOUBLE] END as x
FROM range(1, 8) t(i);

query I
SELECT
    COUNT(*) as reduced_predictions
FROM (
    SELECT
        id,
        anofox_stats_ridge_fit_predict(
            y,
            x,
            MAP{'intercept': 1, 'lambda': 1.0}
        ) OVER (ORDER BY id) as pred
    FROM ridge_inconsistent_features
)
WHERE (pred).yhat IS NOT NULL;
----
7

# Test 6: Single training observation (edge case)
statement ok
CREATE TABLE ridge_single_train AS
SELECT
    i as id,
    i::DOUBLE as x,
    CASE WHEN i = 1 THEN 5.0 ELSE NULL END as y
FROM range(1, 6) t(i);

query I
SELECT
    COUNT(*) as null_predictions
FROM (
    SELECT
        id,
        anofox_stats_ridge_fit_predict(
            y,
            [x],
            MAP{'intercept': 1, 'lambda': 1.0}
        ) OVER (ORDER BY id) as pred
    FROM ridge_single_train
)
WHERE (pred).yhat IS NULL;
----
0

# Test 7: Negative lambda (invalid parameter - should still work but treat as regularization)
statement ok
CREATE TABLE ridge_params AS
SELECT
    i as id,
    i::DOUBLE as x,
    CASE WHEN i <= 5 THEN (i * 2.0)::DOUBLE ELSE NULL END as y
FROM range(1, 9) t(i);

query I
SELECT
    COUNT(*) as predictions
FROM (
    SELECT
        id,
        anofox_stats_ridge_fit_predict(
            y,
            [x],
            MAP{'intercept': 1, 'lambda': 0.0}
        ) OVER (ORDER BY id) as pred
    FROM ridge_params
)
WHERE (pred).yhat IS NOT NULL;
----
8

# Test 8: Very large lambda (extreme shrinkage towards zero)
query I
SELECT
    COUNT(*) as predictions
FROM (
    SELECT
        id,
        anofox_stats_ridge_fit_predict(
            y,
            [x],
            MAP{'intercept': 1, 'lambda': 10000.0}
        ) OVER (ORDER BY id) as pred
    FROM ridge_params
)
WHERE (pred).yhat IS NOT NULL AND ABS((pred).yhat) < 100;
----
8

# Test 9: PARTITION BY with some partitions having insufficient data
statement ok
CREATE TABLE ridge_partial_partitions AS
SELECT
    i as id,
    group_id,
    i::DOUBLE as x,
    CASE
        WHEN group_id = 'A' AND i <= 5 THEN (i * 2.0)::DOUBLE
        WHEN group_id = 'B' AND i <= 1 THEN (i * 3.0)::DOUBLE  -- Insufficient for 1 feature + intercept
        ELSE NULL
    END as y
FROM range(1, 8) t(i),
     (VALUES ('A'), ('B')) g(group_id);

query II
SELECT
    group_id,
    COUNT(*) as predictions
FROM (
    SELECT
        group_id,
        id,
        anofox_stats_ridge_fit_predict(
            y,
            [x],
            MAP{'intercept': 1, 'lambda': 1.0}
        ) OVER (PARTITION BY group_id ORDER BY id) as pred
    FROM ridge_partial_partitions
)
WHERE (pred).yhat IS NOT NULL
GROUP BY group_id
ORDER BY group_id;
----
A	7
B	7

# Test 10: Extreme x values (numerical stability)
statement ok
CREATE TABLE ridge_extreme_values AS
SELECT
    i as id,
    (i * 1000000.0)::DOUBLE as x_large,
    CASE WHEN i <= 5 THEN (i * 2.0)::DOUBLE ELSE NULL END as y
FROM range(1, 9) t(i);

query I
SELECT
    COUNT(*) as predictions
FROM (
    SELECT
        id,
        anofox_stats_ridge_fit_predict(
            y,
            [x_large],
            MAP{'intercept': 1, 'lambda': 1.0}
        ) OVER (ORDER BY id) as pred
    FROM ridge_extreme_values
)
WHERE (pred).yhat IS NOT NULL AND NOT ISINF((pred).yhat) AND NOT ISNAN((pred).yhat);
----
8

# Cleanup
statement ok
DROP TABLE ridge_insufficient;

statement ok
DROP TABLE ridge_all_null;

statement ok
DROP TABLE ridge_empty_features;

statement ok
DROP TABLE ridge_null_features;

statement ok
DROP TABLE ridge_inconsistent_features;

statement ok
DROP TABLE ridge_single_train;

statement ok
DROP TABLE ridge_params;

statement ok
DROP TABLE ridge_partial_partitions;

statement ok
DROP TABLE ridge_extreme_values;
